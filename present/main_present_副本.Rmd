---
title: "High Dimensional Feature Selection with Interactions"
subtitle: "for Time-to-Event Outcome"  
author: 
  - "Lin Yu"
  - 
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    self_contained: true
    css: 
      - xaringan-themer.css
      - extra_css.css
    nature:
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: true
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
  fig.width=9, fig.height=3.5, fig.retina=3,
  out.width = "100%",
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  hiline = TRUE
)

```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_duo_accent(
  primary_color = "#3C989E",        # blue
  secondary_color = "#B2DFDB",      # sea green
  header_font_google = google_font("Lo"),
  text_font_google = google_font("DM Serif Display"),
  header_h1_font_size = "2.75rem",
  header_h2_font_size = "2rem",
  header_h3_font_size = "1.25rem",
  text_font_size = "1rem",
  title_slide_background_color = "#B2DFDB",
  title_slide_background_image = 'background_png.png',
  
 
)


```


```{r xaringanExtra-search, echo=FALSE}
xaringanExtra::use_search(show_icon = TRUE)
xaringanExtra::style_search(match_background = "skyblue")
xaringanExtra::use_clipboard()
xaringanExtra::use_scribble()
xaringanExtra::use_tile_view() ## press O 
xaringanExtra::use_progress_bar(color = "#3C989E", location = "bottom")
xaringanExtra::use_extra_styles(
  hover_code_line = TRUE,         
  mute_unhighlighted_code = TRUE  
)
```

```{r xaringan-fit-screen, echo=FALSE}
xaringanExtra::use_fit_screen()
```

# Background

---
class: center, middle 
> ## Objective: Can HDSI be applied to time-to-Event outcome?


---
# Methods

---
## Step 1: Simulate Time-to-Event Data
.pull-left[       
<img src="01survival_dat.png" style="width: 95%"/> 
]

.pull-right[       
> ### how to simulate features?

- Assumption: $X_p$ ~ normal distribution 
- pre-specified correlation matrix

]

.pull-left[       
- Dimension:  $nÂ·(p+2)$  
<br>     
 - n observations 
 - p features
 - outcome: survival time and status
]

--
.pull-right[       
>### how to simulate time & status?

  Assumptions:
  - Survival time ~ exp( $\lambda$ )
  - Censoring time ~ unif(0,b)
]

---
## Step 1: Simulate Time-to-Event Data (cont'd)
.pull-left[
###CDF of survival function of Cox model             

  $F(t|X) = 1 - S(t|Z) = 1 - e^{ H_0(t)*e^{\beta X}}$  
-  $F(t|Z)$: CDF of survival function 

- $S(t|Z)$: survival function

- $H_0(t)$: CDF of hazard function

- $X$: feature vector, $\beta$ is the coefficient vector
]
--
.pull-right[
###Nice properties of uniform(0,1)
- Property 1: $T|X$ ~ F implies $F(T|X)$ ~ Unif(0,1)

  - $F(T|X) =1 - e^{ H_0(T)*e^{\beta X}}$ ~Unif(0,1)

- Property 2: $U$ ~Unif(0,1), then $1-U$ ~ Unif(0,1)
  - $U = e^{ H_0(T)*e^{\beta X}}$ ~Unif(0,1)
  
  - $T = H_0^{-1}[-log(U)e^{(-\beta X)}]$
]  
--
.pull-left[
Step 1a)  
- features ~ normal
- $T = H_0^{-1}[-log(U)e^{(-\beta X)}]$     
- Censoring time ~ uniform
]
--
.pull-right[
Step 1b)
- time = $min$(T,Censoring time)
- status = $I$(T < Censoring time)
]

---
## Step 2: Generate Bootstrap Sets
> step 2a) Generate **One** Bootstrap Set

<br>
<img src="02boot1.png" width="31%" height="350">
<img src="02boot2.png" width="33%" height="350">
<img src="02boot3.png" width="35%" height="350">
---
## Step 2: Generate Bootstrap Sets

> step 2b) Generate **B** Bootstrap Set: [repeat Step 2a) B times]

<br>
<img src="02boot4.png">

---
## Step 3: Build Model 

Step 3a) For the $j^th$ bootstrap set, we apply lasso/ridge to fit a model:

.pull-left[<img src="03model_dat.png" width="75%">
- for illustration purpose,
consider two features

- n observations]               


.pull-right[<img src="03model_out.png" width="80%">
$X_i: i^{th} \text{feature, } i \in \{ \text{1,2,3,...p,p+1,...}{p\choose 2}\}$

$\hat{\beta_i^j} \text{ :estimate of } X_i \text{ in the } j^{th} \text{ bootstrap set, } j \in \{ \text{1,2,3,...k}\}$

$C_i^j \text{ :C index of } X_i \text{ in the } j^{th} \text{ bootstrap set, }j \in \{ \text{1,2,3,...k}\}$
]


---

## Step 3: Build Model
Step 3b) Repeat 3a) for all boostrap sets:

<img src="03model_out1.png" width="80%">

Step 3c) Pool results:        

$$\hat{\beta_i} = \sum_{j=1}^{k}\hat{\beta}_i^j/b_j$$

$$C_i =min(C_i^j) $$

$\beta_i$: pooled coefficient estimate of  $X_i$


$b_j$: the number of bootstrap sets containing $X_i$
---
## Step 4 Hyperparameter Tunining 

 

- Remove noisy features


### Existing Algorithms Do not Consider Interaction effects
- random









---
class: center, middle 
```{r echo=FALSE, fig.height=6.5, fig.width=8, dpi=300}
## this is a test
```

---
## Notation
Original dataset:
- Sample size (n): total number of observations
- feature dimension (p): total number of features

Feature selection
1. prepare bootstrap samples
- each bootstrapped data set has
  - n observations (use bootstrap with replacement)
  - q features (hyperparameter bootstrap without replacement)
  
2. prepare interaction terms

3. apply lasso, adaptive lasso, regression to get the estimates of all beta coefficients

4. compute averaged value of beta estimate, and min(R^2) of each feature

5. select features using two criteria:
  - quantiles of B estimates should not include zero (significant) (hyperparameter)
  - 
  


  
  


